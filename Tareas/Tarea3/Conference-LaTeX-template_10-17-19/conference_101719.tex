\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage[hidelinks]{hyperref}
\urlstyle{same}
\usepackage[spanish,es-tabla]{babel}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\decimalpoint
\renewcommand{\labelitemi}{$\bullet$}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
    
    
 \input{librerias}
\begin{document}

\title{Evolución diferencial y LSHADE aplicado a función de 10 variables
}

\author{\IEEEauthorblockN{ Ciro Fabian Bermudez Marquez}
INAOE\\
Mexico, Puebla \\
\url{cirofabian.bermudez@gmail.com}
}

\maketitle

\begin{abstract}
En este trabajo se pone a prueba el algoritmo de evolución diferencial (ED) para un problema de minimización de una función de 10 variables implementado en python.
\end{abstract}

\begin{IEEEkeywords}
ED, python, heuristica.
\end{IEEEkeywords}

\section{Introducción}

La evolución diferencial usa números reales en su presentación de las variables, en general realiza un mejor trabajo que el algoritmo genético y se pude  usar una condición automática de paro. 

Las heurísticas se deben usar si el problema tiene tres o más variables y en este trabajo se estudiará la evolución diferencial (ED) aplicado a una función de 10 variables.

\begin{equation}
 f_{1}(x) = 0.1 \sum_{i=1} ^{10} (x_{i} -2)(x_{i} -5) + \sin(1.5 \pi x_{i})
 \end{equation} 
teniendo en cuenta las siguientes características para el algoritmo 
$C = 0.8$, $R = 0.6$, $\mu = 100$, $g=50, 100, 150$, espacio de búsqueda $x_{i}  = [0,7]$ para todas las $i = \{1, 2, \ldots,10\}$ .


\section{La evolución diferencial}


El algoritmo requiere las siguientes variables para su funcionamiento:
\begin{itemize}
\item Tamaño de población $\mu$
\item Numero de generaciones $g$
\item Valor del constante de recombinación $R$
\item Valor del constante de diferencias $F$
\item Valor del umbral $s$.
\end{itemize}

Para un problema de $n$ variables el tamaño de población debe ser igual a $10n$, el número de generaciones a probar serán 30, 50, 100, 150.

Si $R, F = [0,1]$ son iguales a 1 se está usando una búsqueda aleatoria. $s$ está definido en el espacio de la función. Si se tiene un umbral $u$ significa 0.1$u$ en las variables. Si se tiene una precisión $1 \times 10^{-5}$, equivale a $1 \times 10^{-6}$ en las variables.


\section{Resultados ED}

Lo primero que hay que hacer es cambiar la función objetivo del archivo \textbf{evalua.py} de la siguiente manera:


\lstinputlisting[style = PYTHON, caption =  Generar número aleatorio flotante., label = cod:random]{newton3.py}

Y haciendo las modificaciones al archivo \textbf{corre.py} con las especificaciones del problema se obtuvo lo siguiente:

\begin{table}[!hbp]   
	\caption{Resultados de algoritmo ED.}                                                                                                                
		\centering                                       
		\begin{tabular}{cc}
			\hline                                             
			\#{} Generaciones & Mínimo \\                     
			\hline 
			50 & -2.270374746463768\\                                            
			100 & -2.8987574063291177\\
			150 & -3.1971969909333335\\
			200 & -3.219405568513535\\
			500 & -3.224518002922993\\
			1000 & -3.224518002922993\\
			\hline                                             
		\end{tabular}
	\end{table}	
	
	Sabemos que el mínimo se encuentra en $x = 3.652887442162$ y $f_{1}(x)= $ -3.224518019 y con 150 generaciones ya nos aproximamos bastante al resultado.

\section{Resultados LSHADE}


Para el algoritmo de LSHADE se requieren los siguientes datos:
\begin{itemize}
\item g\_{}problem\_{}size = 10
\item g\_{}max\_{}num\_{}evaluations = 20000
\item seed, se ingresa manualmente
\item g\_{}pop\_{}size = 180
\end{itemize}
Los datos anteriores se ingresaron de esa manera dadas las recomendaciones del algoritmo

Como el algoritmo esta escrito en c++ se modifico el archivo \textbf{evaluate.cc} para ajustar la función objetivo de la siguiente manera:

\lstinputlisting[style = CC, caption =  Generar número aleatorio flotante., label = cod:dd]{evaluate.cc}

y se obtuvieron los siguientes resultados:

\begin{table}[!hbp]   
	\caption{Resultados de algoritmo LSHADE.}                                                                                                                
		\centering                                       
		\begin{tabular}{cc}
			\hline                                             
			\#{} seed & Mínimo \\                     
			\hline 
			3 & -3.22451802e+00\\       
			20 & -3.22451802e+00\\                                      
			100 & -3.22451802e+00\\  
			\hline                                             
		\end{tabular}
	\end{table}	
	
	Variando el número máximo de evaluaciones a valores mayores no afecta el resultado y es necesario disminuirlo considerablemente para que el algoritmo empiece a alejarse de una buena solución.

\section{Conclusiones}

La ED necesito de al menos 500 generaciones para encontrar un buen resultado, esto depende de igual manera de la sintonización que uno haga a los parámetros del algoritmo sin embargo pese a esto hizo un buen trabajo en un tiempo relativamente corto para encontrar una solución aceptable, esto también se puede ver opacado debido a que este algoritmo se ejecuto en python. En cuanto a LSHADE, este algoritmo fue más sencillo de utilizar, las mismas instrucciones del código fuente facilitaron de gran manera su aplicación, debido a que este último esta escrito en c++ su ejecución fue más rápida y con las recomendaciones rápidamente se encontró una solución aceptable.

\begin{thebibliography}{00}
\bibitem{b1}  Dr. Luis Gerardo de la Fraga. ``Apuntes de clase'' .
\end{thebibliography}


\end{document}
